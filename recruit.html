<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DigiCD Tutorial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
html, body {
    overflow-x: hidden;
    height: 100%;
    width: 100%;
}

        body {
            margin: 0;
            font-family: system-ui, -apple-system, sans-serif;
            min-height: 100vh;
            width: 100%;
            position: relative;
        }

        #gradientCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .tutorial-window {
            background: rgba(255, 255, 255, 0.95);
            padding: 2.5rem;
            border-radius: 12px 0px 12px 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            margin: 0;
            padding: 2.5rem;
            box-sizing: border-box;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) translateY(20px);
            opacity: 0;
            transition: all 0.5s ease;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            border: 1px solid rgb(0, 0, 0);
            pointer-events: none;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        .tutorial-window.active {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: all;
        }

        .next-button {
            display: flex;
            width: 128px;
            height: fit-content;
            background-color: #1d2129;
            border-radius: 40px;
            box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.1);
            justify-content: space-between;
            align-items: center;
            border: none;
            cursor: pointer;
            align-self: flex-end;
            margin-top: 1.5rem;
            padding: 0;
            transition: all 0.3s ease;
        }

        .next-button .text {
            width: calc(120px - 32px);
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            letter-spacing: 1px;
            padding: 8px 0;
        }

        .next-button .icon-container {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 2px solid #1d2129;
            transition: all 0.3s ease;
        }

        .next-button svg {
            width: 12px;
            height: 14px;
            transition-duration: 1.5s;
        }

        .next-button:hover svg {
            animation: arrow 1s linear infinite;
        }

        @keyframes arrow {
            0% {
                opacity: 0;
                transform: translateX(0);
            }
            100% {
                opacity: 1;
                transform: translateX(10px);
            }
        }

        /* Custom colors for each step */
        .tutorial-window[data-step="1"] .next-button .icon-container {
            background-color: #9ED2C6;
        }

        .tutorial-window[data-step="2"] .next-button .icon-container {
            background-color: #FF7BAC;
        }

        .tutorial-window[data-step="3"] .next-button .icon-container {
            background-color: #000;
        }



        .next-button.disabled .text {
            color: #999;
        }

        .next-button.disabled .icon-container {
            background-color: #ddd;
            border-color: #f5f5f5;
        }

        .next-button.disabled svg {
            opacity: 0.5;
        }

        .highlight {
            color: #0078d4;
            font-weight: bold;
        }

        .arrow {
            position: absolute;
            width: 50px;
            height: 50px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .arrow.visible {
            opacity: 1;
        }


        .next-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .next-button.disabled .icon-container {
            opacity: 0.7;
            border-color: #404652;
        }

        .next-button.disabled:hover .icon-container svg {
            animation: none;
        }

        .next-button.disabled:hover {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Make sure all buttons use these styles */
        a.next-button {
            text-decoration: none;
            color: white;
        }

        .highlight {
            color: #0078d4;
            font-weight: bold;
        }

        .arrow {
            position: absolute;
            width: 50px;
            height: 50px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .arrow.visible {
            opacity: 1;
        }

        .tutorial-window::before {
            content: '';
            text-align: right;
            padding: 0 12px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: right;
            position: absolute;
            border-radius: 10px 10px 0 0;
            top: -20px;
            right: 0;
            width: 25%;
            height: 21px;
            box-sizing: border-box;
            z-index: -1;
            clip-path: polygon(18% 0, 100% 0, 100% 100%, 0% 100%);
        }

        .tutorial-window::after {
            content: '';
            position: absolute;
            top: -21px;
            right: -1px;
            border-top-right-radius: 11px;
            width: calc(25% + 2px);
            height: 21px;
            background-color: black;
            z-index: -2;
            clip-path: polygon(18% 0, 100% 0, 100% 100%, 0% 100%);;
        }

        .tutorial-window[data-step="1"]::before {
            content: 'Welcome to DigiCDs!';
            /* background: #9ED2C6;  Soft mint/sage */
            background: linear-gradient(to bottom, #9ED2C6 0%, #9ED2C6 calc(100% - 2px), #a5d8cd 100%);
        }

        .tutorial-window[data-step="1"]{
            background: linear-gradient(to bottom, #9ED2C6 0%, #ffffffe9 5%);
        }
        
        .tutorial-window[data-step="2"]::before {
            content: 'Step 1: Get a DigiCD';
            background: linear-gradient(to bottom, #FF7BAC 0%, #FF7BAC calc(100% - 2px), #ff88b3 100%);
        }
        
        .tutorial-window[data-step="2"]{
            background: linear-gradient(to bottom, #FF7BAC 0%, #ffffffe9 5%);
        }
        
        .tutorial-window[data-step="3"]::before {
            background: linear-gradient(to bottom, #000000 0%, #000000 calc(100% - 2px), #141414 100%);
            color: #fff;
            content: 'Step 2: Play Music';
        }

        .tutorial-window[data-step="3"]{
            background: linear-gradient(to bottom, #000000 0%, #ffffffe9 5%);
        }

        /* .tutorial-window::after {
            content: '';
            position: absolute;
            border-radius: 0px 0px 10px 10px;
            bottom: -20px;
            left: 0;
            width: 25%;
            height: 20px;
            background: inherit;
            z-index: 999;
            clip-path: polygon(0 0, 100% 0, 82% 100%, 0% 100%);
        } */



        #characterContainer {
            position: absolute;
            top: -30px;
            right: 10px;
            width: 100px;
            height: 100px;
            z-index: 1;
        }

        .speech-bubble {
            position: fixed;
            bottom: calc(50% + 160px);
            right: calc(20% + 100px);
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            filter: drop-shadow(0 1px 1px rgb(0, 0, 0));
            max-width: 200px;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            font-size: .75rem;
            font-family: 'comic sans ms', system-ui, -apple-system, sans-serif;
            z-index: 1;
            width: fit-content;
            height: fit-content;
            box-sizing: border-box;
        }

        .speech-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(
                    circle at 2px 2px,
                    rgba(0, 145, 255, 0.661) 1.5px,
                    transparent 2px
                );
            background-size: 3px 3px;
            border-radius: 15px;
            opacity: 0.8;
            mask-image: linear-gradient(to bottom,
                rgba(0, 0, 0, 1) 0%,
                rgba(0, 0, 0, 0.2) 20%,
                rgba(0, 0, 0, 0) 100%
            );
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .speech-bubble.visible {
            opacity: 1;
            transform: scale(1);
        }

        .speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            right: 30px;
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: white transparent;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));
            z-index: 2;
        }

        /* Make the "go to player" link button consistent */
        .tutorial-window[data-step="3"] .next-button {
            display: flex;
            text-decoration: none;
            color: inherit;
        }

        .tutorial-window h2 {
            margin: 0 0 1.5rem 0;
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            line-height: 1.2;
            color: #1d2129;
        }

        .tutorial-window p {
            margin: 0 0 1.2rem 0;
            font-size: 1rem;
            line-height: 1.6;
            color: #4b5563;
            font-weight: 400;
        }

        .tutorial-window ol {
            margin: 1rem 0;
            padding-left: 1.2rem;
            color: #4b5563;
        }

        .tutorial-window li {
            margin-bottom: 0.8rem;
            line-height: 1.5;
            font-size: 1rem;
        }

        .tutorial-window li:last-child {
            margin-bottom: 0;
        }

        /* Add font import at the top of your CSS */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

        /* Add these new styles */
        .button-container {
            position: relative;
            align-self: flex-end;
            margin-top: 1.5rem;
        }

        .button-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: -1;
        }

        .next-button {
            position: relative;
            z-index: 1;
            background-color: rgba(29, 33, 41, 0.9); /* Slightly transparent */
            /* Remove margin-top since it's now handled by container */
            margin-top: 0;
        }

        /* Add new background canvas style */
        .tutorial-window-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            border-radius: 12px;
        }

        /* Add new canvas style for the title effect */
        .title-canvas {
            position: absolute;
            top: -20px;
            right: -40px;
            width: 25%;
            height: 20px;
            z-index: -2;
            clip-path: polygon(18% 0, 100% 0, 100% 100%, 0% 100%);
        }

        /* Update step-specific styles */
        .tutorial-window[data-step="1"] .title-text {
            position: absolute;
            top: -20px;
            right: 0;
            width: 25%;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: right;
            font-size: 8px;
            z-index: 1;
            pointer-events: none;
            content: '';
        }

        .tutorial-window[data-step="2"] .title-text {
            content: 'Step 1: Get a DigiCD';
        }

        .tutorial-window[data-step="3"] .title-text {
            content: 'Step 2: Play the Music';
            color: #fff;
        }

        .page-wrapper {
            position: relative;
            min-height: 100vh;
            width: 100%;
            overflow-x: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Add media query for smaller screens */
        @media screen and (max-width: 600px) {
            .tutorial-window {
                width: 90vw;  /* Use viewport width unit */
                padding: 1.5rem;  /* Slightly smaller padding on mobile */
            }
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <canvas id="gradientCanvas"></canvas>
        <div id="characterContainer"></div>
        <div class="tutorial-window" data-step="1">
            <canvas class="title-canvas"></canvas>
            <h2>Welcome to DigiCDs!</h2>
            <p>A DigiCD is a digital avatar of a CD. Let me show you how it works.</p>
            <div class="button-container">
                <button class="next-button">
                    <span class="text">Next Step</span>
                    <span class="icon-container">
                        <svg width="16" height="19" viewBox="0 0 16 19" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="1.61321" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="13.9811" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="1.61321" cy="17.3868" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="17.3868" r="1.5" fill="white"></circle>
                        </svg>
                    </span>
                </button>
            </div>
        </div>

        <div class="tutorial-window" data-step="2">
            <canvas class="title-canvas"></canvas>
            <h2>Step 1: Get a DigiCD</h2>
            <p>First, let's download a sample DigiCD from our library. Click the CD image below to download "Winter of Tandy".</p>
            <div style="text-align: center; margin: 1rem 0;">
                <a href="./pages/library/CDs/WinterofTandy.png" download 
                   onclick="if(helper) { 
                       helper.growLimbsAnimation('Wow! That\'s my favorite DigiCD!'); 
                   }">
                    <img src="./pages/library/CDs/WinterofTandy.png" alt="Winter of Tandy DigiCD" 
                         style="width: 150px; height: 150px; border-radius: 50%; cursor: pointer; 
                                transition: transform 0.3s ease; box-shadow: 0 4px 8px rgba(0,0,0,0.2);"
                         onmouseover="this.style.transform='scale(1.05)'" 
                         onmouseout="this.style.transform='scale(1)'">
                </a>
            </div>
            <div class="button-container">
                <button class="next-button">
                    <span class="text">next step</span>
                    <span class="icon-container">
                        <svg width="16" height="19" viewBox="0 0 16 19" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="1.61321" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="13.9811" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="1.61321" cy="17.3868" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="17.3868" r="1.5" fill="white"></circle>
                        </svg>
                    </span>
                </button>
            </div>
        </div>

        <div class="tutorial-window" data-step="3">
            <canvas class="title-canvas"></canvas>
            <div class="title-text">Step 2: Play the Music</div>
            <h2>Step 2: Play the Music</h2>
            <p>Now that you have a DigiCD, let's play it! I'll take you to the player where you can:</p>
            <ol>
                <li>Click "Insert DigiCD"</li>
                <li>Select the DigiCD file you just downloaded</li>
                <li>Click the play button</li>
            </ol>
            <div class="button-container">
                <button class="next-button">
                    <span class="text">go to player</span>
                    <span class="icon-container">
                        <svg width="16" height="19" viewBox="0 0 16 19" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="1.61321" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="1.61321" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="5.5566" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="13.9811" cy="9.5" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="9.85851" cy="13.4434" r="1.5" fill="white"></circle>
                            <circle cx="1.61321" cy="17.3868" r="1.5" fill="white"></circle>
                            <circle cx="5.73583" cy="17.3868" r="1.5" fill="white"></circle>
                        </svg>
                    </span>
                </button>
            </div>
        </div>

        <div class="speech-bubble"></div>
    </div>
    <script>
        let currentStep = 1;
        const totalSteps = 3;
        let tutorialGradient;

        function showStep(step) {
            document.querySelectorAll('.tutorial-window').forEach(window => {
                window.classList.remove('active');
            });
            const currentWindow = document.querySelector(`[data-step="${step}"]`);
            currentWindow.classList.add('active');
            
            // Handle step 2 specific logic
            if (step === 2) {
                const nextButton = currentWindow.querySelector('.next-button');
                nextButton.classList.add('disabled');
                
                // Add hover effect on disabled button
                nextButton.addEventListener('mouseenter', () => {
                    if (nextButton.classList.contains('disabled')) {
                        highlightCD();
                        if (helper) {
                            helper.growLimbsAnimation('Click the CD to download it first!');
                        }
                    }
                });

                // nextButton.addEventListener('mouseleave', () => {
                //     if (helper) {
                //         helper.stopTalking();
                //         helper.shrinkLimbsAnimation();
                //     }
                // });

                // Trigger initial animation after a short delay
                setTimeout(highlightCD, 1000);
            }
            
            // Update character color
            if (helper) {
                helper.updateColor(step);
            }
            
            // Change gradient color on step change
            if (tutorialGradient) {
                tutorialGradient.nextColor();
            }
        }

        document.querySelectorAll('.next-button').forEach(button => {
            button.addEventListener('click', () => {
                // Only proceed if button isn't disabled
                if (!button.classList.contains('disabled')) {
                    if (currentStep < totalSteps) {
                        if (helper) {
                            helper.stopTalking();
                            if (currentStep === 2) {
                                helper.shrinkLimbsAnimation();
                            }
                        }
                        currentStep++;
                        showStep(currentStep);
                        if (helper) {
                            helper.flyToNextWindow(currentStep);
                        }
                    }
                }
            });
        });

        document.querySelector('[data-step="3"] .next-button').addEventListener('click', (e) => {
            e.preventDefault();
            
            if (helper) {
                helper.isTransitioning = true;
                
                const timeline = gsap.timeline({
                    onComplete: () => {
                        window.location.href = './indexNew.html';
                    }
                });

                // Get initial position and size
                const initialRect = helper.characterContainer.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                // Calculate center position
                const targetTop = windowHeight / 2 - 50;
                const targetRight = windowWidth / 2 + 26;

                timeline.to('[data-step="3"]', {
                    opacity: 0,
                    duration: 0.3
                });

                // First, rotate to face forward
                timeline.to(helper.clip.rotation, {
                    y: 0,
                    duration: 0.5,
                    ease: "power2.inOut",
                    onComplete: () => {
                        helper.clip.rotation.y = 0;
                    }
                });

                timeline.to({}, {duration: 0.2});

                // Move to center and increase renderer size
                timeline.to(helper.characterContainer, {
                    top: targetTop,
                    right: targetRight,
                    xPercent: 50,
                    yPercent: -50,
                    duration: 1,
                    ease: "power2.inOut",
                    onStart: () => {
                        // Calculate the size difference
                        const oldSize = 150;
                        const newSize = 600;
                        const sizeDiff = newSize - oldSize;
                        
                        // Update camera position and renderer size for the larger scale
                        helper.renderer.setSize(newSize, newSize);
                        helper.camera.position.z = 12;
                        helper.camera.aspect = 1;
                        helper.camera.updateProjectionMatrix();
                        
                        // Adjust container position to compensate for size increase
                        helper.characterContainer.style.marginTop = `-${sizeDiff/2}px`;
                        helper.characterContainer.style.marginRight = `${sizeDiff/2}px`;
                    }
                });

                // Combined scale and rotation
                const scaleDuration = 2; // Longer duration
                
                timeline.to(helper.clip.scale, {
                    x: 2.5,  // Slightly larger initial scale
                    y: 2.5,
                    z: 2.5,
                    duration: scaleDuration,
                    ease: "power2.inOut"
                }, "-=0.5");

                timeline.to(helper.clip.rotation, {
                    z: Math.PI * 2,
                    duration: 1,
                    ease: "power2.inOut",
                    onComplete: () => {
                        helper.clip.rotation.z = 0;
                    }
                }, `-=${scaleDuration - 0.8}`);

                // Shrink limbs
                timeline.to([
                    helper.leftArm.scale,
                    helper.rightArm.scale,
                    helper.leftLeg.scale,
                    helper.rightLeg.scale,
                    helper.leftEye.scale,
                    helper.rightEye.scale,
                    helper.mouth.scale
                ], {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 0.5,
                    ease: "power2.in"
                });

                // Final scale up
                timeline.to(helper.clip.scale, {
                    x: 8,    // Much larger final scale
                    y: 8,
                    z: 8,
                    duration: 0.5,
                    ease: "power2.in"
                }, "-=0.4");


                timeline.to(helper.clipMaterial, {
                    opacity: 0,
                    duration: 0.4,
                    ease: "power2.in",
                    onStart: () => {
                        helper.clipMaterial.transparent = true; // Enable transparency
                    }
                }, "-=0.4"); // Start fade earlier to blend with scaling

                const flash = document.createElement('div');
                flash.style.position = 'fixed';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.right = '0';
                flash.style.bottom = '0';
                flash.style.backgroundColor = 'white';
                flash.style.opacity = '0';
                flash.style.zIndex = '9999';
                document.body.appendChild(flash);

                timeline.to(flash, {
                    opacity: 1,
                    duration: 0.3,
                    ease: "power2.in"
                });
            }
        });

        // Add the character setup
        class RecruitmentHelper {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 150 / 150, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(150, 150);
                this.talking = false;
                this.isSpeaking = false;
                this.speechTimeout = null;
                
                document.getElementById('characterContainer').appendChild(this.renderer.domElement);
                // const clipGeometry = new THREE.TorusGeometry(0.5, 0.35, 16, 100);
                // clipGeometry.scale(.6, .6, .1);
                
                // // Store material reference for color updates
                // this.clipMaterial = new THREE.MeshPhysicalMaterial({ 
                //     color: 0x2d8fda,  // Start with first step color
                //     shininess: 100,
                //     roughness: 0.0,
                //     metalness: 0.5,
                //     reflectivity: 1,
                //     clearcoat: 1,
                //     clearcoatRoughness: 0.5,
                //     clearcoatGloss: 1,
                // });
                // Create clippy-style character
                const clipGeometry = new THREE.TorusGeometry(0.5, 0.1, 16, 100);
                
                // Store material reference for color updates
                this.clipMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2d8fda,  // Start with first step color
                    shininess: 100
                });
                this.clip = new THREE.Mesh(clipGeometry, this.clipMaterial);
                
                // Add eyes
                this.eyeGeometry = new THREE.SphereGeometry(0.08, 32, 32);
                this.eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.leftEye = new THREE.Mesh(this.eyeGeometry, this.eyeMaterial);
                this.rightEye = new THREE.Mesh(this.eyeGeometry, this.eyeMaterial);
                
                this.leftEye.position.set(-0.2, 0.3, 0.2);
                this.rightEye.position.set(0.2, 0.3, 0.2);
                
                // Add mouth (smaller, oval-shaped ring)
                const mouthGeometry = new THREE.TorusGeometry(0.2, 0.05, 16, 100);
                const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                
                // Lower position and make more oval
                this.mouth.position.set(0, -0.15, 0.2);  // Lowered position
                this.mouth.rotation.x = Math.PI * 0.1;  // Tilt for visibility
                this.mouth.scale.y = 0.25;  // Squash vertically to make oval
                this.mouth.scale.z = .5
                
                this.clip.add(this.leftEye);
                this.clip.add(this.rightEye);
                this.clip.add(this.mouth);
                
                // Add arms (cylinders)
                const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 32);
                
                // Left arm
                this.leftArm = new THREE.Mesh(armGeometry, this.eyeMaterial);
                this.leftArm.position.set(-0.6, -0.1, 0.2);
                this.leftArm.rotation.z = Math.PI * 0.15; // Angle slightly outward
                this.leftArm.rotation.x = Math.PI * 0.75;  // Rotate to correct orientation

                // Right arm
                this.rightArm = new THREE.Mesh(armGeometry, this.eyeMaterial);
                this.rightArm.position.set(0.6, -0.1, 0.2);
                this.rightArm.rotation.z = -Math.PI * 0.15; // Angle slightly outward
                this.rightArm.rotation.x = Math.PI * 0.75;   // Rotate to correct orientation

                // Add hands (small spheres)
                const handGeometry = new THREE.SphereGeometry(0.08, 32, 32);
                this.handMaterial = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
                
                // Left hand
                this.leftHand = new THREE.Mesh(handGeometry, this.clipMaterial);
                this.leftHand.position.set(0, 0.3, 0);  // Changed from -0.3 to 0.3
                this.leftArm.add(this.leftHand);

                // Right hand
                this.rightHand = new THREE.Mesh(handGeometry, this.clipMaterial);
                this.rightHand.position.set(0, 0.3, 0);  // Changed from -0.3 to 0.3
                this.rightArm.add(this.rightHand);

                // Add arms to main clip
                this.clip.add(this.leftArm);
                this.clip.add(this.rightArm);

                // Add lighting
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 1, 2);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                
                this.scene.add(this.clip);
                this.camera.position.z = 3;
                
                this.animate();
                
                // Add bounce animation
                this.bounceAnimation();

                // Add arm animation
                this.armAnimation();

                // Add legs (cylinders)
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 32);
                
                // Left leg - adjust position to be more vertical
                this.leftLeg = new THREE.Mesh(legGeometry, this.eyeMaterial);
                this.leftLeg.position.set(-0.2, -0.65, -0.1); // Moved forward in z-axis and closer to center
                // this.leftLeg.rotation.z = Math.PI * 0.05; // Smaller outward angle
                // this.leftLeg.rotation.x = Math.PI * 0.2; // Less tilt forward

                // Right leg - adjust position to be more vertical
                this.rightLeg = new THREE.Mesh(legGeometry, this.eyeMaterial);
                this.rightLeg.position.set(0.2, -0.65, -0.1); // Moved forward in z-axis and closer to center
                // this.rightLeg.rotation.z = -Math.PI * 0.05; // Smaller outward angle
                // this.rightLeg.rotation.x = Math.PI * 0.2; // Less tilt forward

                // Add feet (small spheres)
                const footGeometry = new THREE.SphereGeometry(0.08, 32, 32);
                
                // Left foot - adjust position
                this.leftFoot = new THREE.Mesh(footGeometry, this.clipMaterial);
                this.leftFoot.position.set(0, -0.2, 0.0); // Move to bottom of leg
                this.leftLeg.add(this.leftFoot);

                // Right foot - adjust position
                this.rightFoot = new THREE.Mesh(footGeometry, this.clipMaterial);
                this.rightFoot.position.set(0, -0.2, 0.0); // Move to bottom of leg
                this.rightLeg.add(this.rightFoot);

                // Add legs to main clip
                this.clip.add(this.leftLeg);
                this.clip.add(this.rightLeg);

                // Adjust leg animation for standing position
                this.legAnimation();

                // Initialize limbs with scale 0
                this.leftArm.scale.set(0, 0, 0);
                this.rightArm.scale.set(0, 0, 0);
                this.leftLeg.scale.set(0, 0, 0);
                this.rightLeg.scale.set(0, 0, 0);
                this.leftHand.scale.set(0, 0, 0);
                this.rightHand.scale.set(0, 0, 0);
                this.leftFoot.scale.set(0, 0, 0);
                this.rightFoot.scale.set(0, 0, 0);

                // Initialize mouth with scale 0
                this.mouth.scale.set(0, 0, 0);

                // Add all animations EXCEPT growLimbsAnimation
                this.armAnimation();
                this.legAnimation();
                this.bounceAnimation();

                // Add initial position
                this.characterContainer = document.getElementById('characterContainer');
                this.initialPosition = { x: 10, y: -30 };  // Original position
                this.characterContainer.style.position = 'absolute';
                this.characterContainer.style.right = this.initialPosition.x + 'px';
                this.characterContainer.style.top = this.initialPosition.y + 'px';

                // Add resize listener
                window.addEventListener('resize', () => {
                    const currentStep = document.querySelector('.tutorial-window.active').dataset.step;
                    this.flyToNextWindow(currentStep);
                });

                // Create a wrapper div for better hover detection
                const wrapperDiv = document.createElement('div');
                wrapperDiv.style.width = '80px';  // Actual character size
                wrapperDiv.style.height = '80px';
                wrapperDiv.style.position = 'absolute';
                wrapperDiv.style.left = '50%';
                wrapperDiv.style.top = '50%';
                wrapperDiv.style.transform = 'translate(-50%, -50%)';
                wrapperDiv.style.cursor = 'pointer';
                // wrapperDiv.style.border = '1px solid red';  // Uncomment for debugging

                // Move event listeners from characterContainer to wrapper
                wrapperDiv.addEventListener('mouseenter', this.handleInteraction.bind(this));
                wrapperDiv.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleInteraction(e);
                }, { passive: false });

                // Add wrapper to character container
                this.characterContainer.appendChild(wrapperDiv);

                // Add this property to the constructor
                this.isMovingAway = false;

                // Add new property to track if first interaction has happened
                this.hasInteracted = false;

                // Add personality flag - true for grumpy, false for friendly
                this.isGrumpy = true;

                // Add response collections
                this.grumpyResponses = [
                    "Hey don't f%$king touch me!"
                ];

                this.friendlyResponses = [
                    "Hehe, that tickles! ðŸ˜Š",
                    "Aww, you're friendly!",
                    "Hi there! Nice to meet you!",
                    "*happy wiggle*",
                    "You found the secret interaction!",
                    "Yay, a new friend!",
                    "High five! âœ‹",
                    "Boop! ðŸ‘‰ðŸ‘ˆ",
                    "Virtual hugs! ðŸ¤—",
                    "You're good at finding Easter eggs!"
                ];
            }
            
            animate = (frame) => {
                requestAnimationFrame(this.animate);
                // Only do the idle animation if we're not in the final transition
                if (!this.isTransitioning) {
                    this.clip.rotation.y = Math.sin(frame * 0.0005) * 0.5;
                }
                this.renderer.render(this.scene, this.camera);
                if(this.talking) {
                    // Start the wave from the current scale to ensure smooth transition
                    const baseScale = 0; // The base scale of the mouth
                    const amplitude = 1; // How much it opens/closes
                    const frequency = 0.05; // Speed of talking
                    
                    // Use a phase offset to ensure we start from the closed position
                    if (!this.mouthPhase) {
                        // Initialize phase to match current position
                        this.mouthPhase = Math.abs(Math.asin((this.mouth.scale.y - baseScale) / amplitude));
                    }
                    
                    this.mouthPhase += frequency;
                    this.mouth.scale.y = baseScale + (amplitude * Math.sin(this.mouthPhase));
                } else {
                    // Reset the phase when not talking
                    this.mouthPhase = null;
                }
            }
            
            bounceAnimation() {
                const timeline = gsap.timeline({ repeat: -1 });
                timeline.to(this.clip.position, {
                    y: 0.4,
                    duration: 0.8,
                    ease: "power1.inOut",
                    yoyo: true,
                    repeat: -1
                });
            }
            
            // Add method to update color
            updateColor(step) {
                const colors = {
                    1: 0x9ED2C6,  // Soft mint/sage
                    2: 0xFF7BAC,  // Vibrant pink
                    3: 0xa0a0a0   // Existing gray
                };
                this.clipMaterial.color.setHex(colors[step]);
                // No need to update arm/hand colors as they use the same material
            }

            armAnimation() {
                const timeline = gsap.timeline({ repeat: -1 });
                
                // Left arm wave - more pronounced
                timeline.to(this.leftArm.rotation, {
                    z: Math.PI * 0.4,
                    duration: 0.8,
                    ease: "power1.inOut",
                    yoyo: true,
                    repeat: -1
                });

                // Right arm wave - more pronounced
                timeline.to(this.rightArm.rotation, {
                    z: -Math.PI * 0.4,
                    duration: 0.8,
                    ease: "power1.inOut",
                    yoyo: true,
                    repeat: -1,
                    delay: 0.4
                }, 0);
            }

            legAnimation() {
                const timeline = gsap.timeline({ repeat: -1 });
                
                // Left leg swing - more pronounced
                timeline.to(this.leftLeg.rotation, {
                    x: Math.PI * 0.35,
                    duration: 0.8,
                    ease: "power1.inOut",
                    yoyo: true,
                    repeat: -1
                });

                // Right leg swing - more pronounced
                timeline.to(this.rightLeg.rotation, {
                    x: Math.PI * 0.35,
                    duration: 0.8,
                    ease: "power1.inOut",
                    yoyo: true,
                    repeat: -1,
                    delay: 0.4
                }, 0);
            }

            growLimbsAnimation(phrase) {
                // Clear any existing timeouts
                if (this.speechTimeout) {
                    clearTimeout(this.speechTimeout);
                    this.speechTimeout = null;
                }
                
                // Reset talking and speech states
                this.talking = false;
                this.isSpeaking = false;
                this.stopTalking();
                
                const timeline = gsap.timeline();
                
                // Start talking immediately if there's a phrase
                if (phrase) {
                    setTimeout(() => {
                        this.startTalking(phrase);
                    }, 100);
                }
                
                // Grow mouth earlier in the animation sequence
                timeline.to(this.mouth.scale, {
                    x: 1,
                    y: 0.25,
                    z: 0.5,
                    duration: 0.8,
                    ease: "elastic.out(2.5, 0.2)",
                    onComplete: () => {
                        // Start the mouth animation
                        this.talking = true;
                    }
                });

                // Rest of the animations remain the same
                timeline.to([
                    this.leftArm.scale, 
                    this.rightArm.scale,
                    this.leftLeg.scale, 
                    this.rightLeg.scale
                ], {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.8,
                    ease: "elastic.out(2.5, 0.2)",
                }, "-=0.6");

                timeline.to([
                    this.leftHand.scale, 
                    this.rightHand.scale,
                    this.leftFoot.scale, 
                    this.rightFoot.scale
                ], {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.8,
                    ease: "elastic.out(2.5, 0.2)",
                }, "-=0.6");

                // Set up auto-hide with longer duration
                if (phrase) {
                    this.speechTimeout = setTimeout(() => {
                        // Only shrink if we're still talking
                        if (this.talking) {
                            this.stopTalking();
                            this.shrinkLimbsAnimation();
                        }
                    }, 4000);
                }

                return timeline;
            }

            shrinkLimbsAnimation() {
                // Don't start shrinking if we're still talking
                if (this.talking) return;
                
                const timeline = gsap.timeline();
                
                // Shrink hands and feet first
                timeline.to([
                    this.leftHand.scale, 
                    this.rightHand.scale,
                    this.leftFoot.scale, 
                    this.rightFoot.scale
                ], {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 0.5,
                    ease: "back.in(1.5)"
                });

                // Shrink arms and legs
                timeline.to([
                    this.leftArm.scale, 
                    this.rightArm.scale,
                    this.leftLeg.scale, 
                    this.rightLeg.scale
                ], {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 0.5,
                    ease: "back.in(1.5)"
                }, "-=0.3");

                // Shrink mouth last
                timeline.to(this.mouth.scale, {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 0.5,
                    ease: "back.in(1.5)"
                }, "-=0.3");
            }

            // Add new method for flying animation
            flyToNextWindow(step) {
                console.log("Current step:", step, typeof step);
                const tutorialWindow = document.querySelector(`[data-step="${step}"]`);
                const windowRect = tutorialWindow.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Create a timeline for smooth animation
                const timeline = gsap.timeline({
                    onComplete: () => {
                        // Show interaction hint after flying in
                        if (step === "2" || step === 2) {
                            setTimeout(() => {
                                this.showInteractionHint();
                            }, 300); // Half second delay after arrival
                        }
                    }
                });
                
                // Special position for step 2 (download step)
                if (step === 2 || step === "2") {  // Check for both string and number
                    // Position significantly to the left of the tutorial window
                    const targetRight = viewportWidth - (windowRect.left + 125);
                    timeline.to(this.characterContainer, {
                        top: windowRect.top + 175,
                        right: targetRight,
                        duration: 0.7,
                        ease: "power1.inOut"
                    });
                } else {
                    // Normal positioning (20% from right) for other steps
                    const finalRight = viewportWidth - windowRect.right + (windowRect.width * 0.2);
                    timeline.to(this.characterContainer, {
                        top: windowRect.top - 30,
                        right: finalRight,
                        duration: 0.7,
                        ease: "power1.inOut"
                    });
                }
            }

            startTalking(message) {
                this.talking = true;
                const speechBubble = document.querySelector('.speech-bubble');
                const characterRect = this.characterContainer.getBoundingClientRect();
                const bubbleRect = speechBubble.getBoundingClientRect();
                
                // Set content first to get accurate dimensions
                speechBubble.textContent = message;
                
                // Calculate initial position
                let rightPosition = window.innerWidth - characterRect.right + 6;
                let bottomPosition = window.innerHeight - characterRect.top - 30;

               
                // Add viewport boundary checks
                const maxRight = window.innerWidth - bubbleRect.width - 10; // 10px margin
                if (rightPosition > maxRight) {
                    rightPosition = maxRight;
                }
                
                // Ensure bubble stays within top viewport boundary
                const minBottom = bubbleRect.height + 10; // 10px margin from top
                if (bottomPosition > window.innerHeight - minBottom) {
                    bottomPosition = window.innerHeight - minBottom;
                }
                
                console.log("bubbleRect", bubbleRect);
                console.log("characterRect", characterRect);
                console.log("rightPosition", rightPosition);
                console.log("bottomPosition", bottomPosition);
                console.log("window.innerWidth", window.innerWidth);
                console.log("window.innerHeight", window.innerHeight);
                console.log("bottomPosition", bottomPosition);
                console.log("rightPosition", rightPosition);
                
                // Apply calculated positions
                speechBubble.style.right = `${rightPosition}px`;
                speechBubble.style.bottom = `${bottomPosition}px`;
                
                // Force a reflow and make visible
                speechBubble.offsetHeight;
                speechBubble.classList.add('visible');
            }

            stopTalking() {
                if (this.speechTimeout) {
                    clearTimeout(this.speechTimeout);
                    this.speechTimeout = null;
                }
                
                this.isSpeaking = false;
                this.talking = false;
                const speechBubble = document.querySelector('.speech-bubble');
                speechBubble.classList.remove('visible');
            }

            handleInteraction(event) {
                if (!this.isTransitioning && !this.isMovingAway) {
                    this.hasInteracted = true;
                    
                    if (this.isGrumpy) {
                        this.isMovingAway = true;
                        
                        // Get current position
                        const rect = this.characterContainer.getBoundingClientRect();
                        const x = event.type === 'touchstart' ? event.touches[0].clientX : event.clientX;
                        const y = event.type === 'touchstart' ? event.touches[0].clientY : event.clientY;
                        
                        // Calculate direction to move away
                        const deltaX = rect.left + rect.width/2 - x;
                        const deltaY = rect.top + rect.height/2 - y;
                        const angle = Math.atan2(deltaY, deltaX);
                        
                        // Calculate new position
                        const distance = 100;
                        const newX = rect.left + Math.cos(angle) * distance;
                        const newY = rect.top + Math.sin(angle) * distance;
                        
                        // Store original position
                        const originalRight = parseInt(window.getComputedStyle(this.characterContainer).right);
                        const originalTop = parseInt(window.getComputedStyle(this.characterContainer).top);
                        
                        // Calculate new right position
                        const newRight = window.innerWidth - newX - rect.width;
                        
                        const timeline = gsap.timeline();
                        
                        // Grow limbs and start talking with grumpy response
                        const response = this.grumpyResponses[Math.floor(Math.random() * this.grumpyResponses.length)];
                        this.growLimbsAnimation(response);
                        
                        // Move away - update both character and speech bubble
                        timeline.to(this.characterContainer, {
                            right: newRight,
                            top: newY,
                            duration: 0.3,
                            ease: "power2.out",
                            onUpdate: () => {
                                // Update speech bubble position relative to character
                                const characterRect = this.characterContainer.getBoundingClientRect();
                                const speechBubble = document.querySelector('.speech-bubble');
                                speechBubble.style.right = `${window.innerWidth - characterRect.right + 6}px`;
                                speechBubble.style.bottom = `${window.innerHeight - characterRect.top - 30}px`;
                            }
                        });
                        
                        // Return to original position
                        timeline.to(this.characterContainer, {
                            right: originalRight,
                            top: originalTop,
                            duration: 0.5,
                            ease: "power2.inOut",
                            delay: 1,
                            onUpdate: () => {
                                // Update speech bubble position relative to character
                                const characterRect = this.characterContainer.getBoundingClientRect();
                                const speechBubble = document.querySelector('.speech-bubble');
                                speechBubble.style.right = `${window.innerWidth - characterRect.right + 6}px`;
                                speechBubble.style.bottom = `${window.innerHeight - characterRect.top - 30}px`;
                            },
                            onComplete: () => {
                                setTimeout(() => {
                                    this.stopTalking();
                                    this.shrinkLimbsAnimation();
                                    this.isMovingAway = false;
                                }, 2000);
                            }
                        });
                        
                    } else {
                        // Friendly behavior - stay put and say something nice
                        const response = this.friendlyResponses[Math.floor(Math.random() * this.friendlyResponses.length)];
                        this.growLimbsAnimation(response);
                        
                        // Add happy wiggle
                        gsap.to(this.clip.rotation, {
                            z: Math.PI * 0.1,
                            duration: 0.2,
                            yoyo: true,
                            repeat: 3,
                            ease: "power1.inOut"
                        });
                        
                        // Auto-hide the response after a few seconds
                        setTimeout(() => {
                            this.stopTalking();
                            this.shrinkLimbsAnimation();
                        }, 3000);
                    }
                }
            }

            // Add new method for the hint
            showInteractionHint() {
                if (!this.hasInteracted) {
                    // Grow limbs temporarily
                    // this.growLimbsAnimation("Psst... I'm your tutorial guide!");
                    // this.growLimbsAnimation("Looking for a guide? That's me!");
                    this.growLimbsAnimation("Hi, I'm Dysko! What's up?");
                    
                    // Add subtle pulse animation to character
                    gsap.to(this.clip.scale, {
                        x: 1.1,
                        y: 1.1,
                        z: 1.1,
                        duration: 0.5,
                        repeat: 3,
                        yoyo: true,
                        ease: "power1.inOut",
                        onComplete: () => {
                            setTimeout(() => {
                                if (!this.hasInteracted) {
                                    this.stopTalking();
                                    this.shrinkLimbsAnimation();
                                }
                            }, 2000);
                        }
                    });
                }
            }
        }

        let helper;  // Store reference to helper

        // Initialize the helper after the page loads
        window.addEventListener('load', () => {
            tutorialGradient = new TutorialGradient();
            helper = new RecruitmentHelper();  // Store reference
            showStep(1);
        });

        // Add this after the button event listeners
        function highlightCD() {
            const cdImage = document.querySelector('[data-step="2"] img');
            cdImage.classList.add('cd-attention');
            cdImage.addEventListener('animationend', () => {
                cdImage.classList.remove('cd-attention');
            });
        }

        // Modify the download onclick handler
        document.querySelector('[data-step="2"] a').addEventListener('click', function(e) {
            const nextButton = document.querySelector('[data-step="2"] .next-button');
            nextButton.classList.remove('disabled');
            if (helper) {
                helper.growLimbsAnimation('Wow! That\'s my favorite DigiCD!');
            }
        });

        document.querySelectorAll('.next-button .text').forEach(textElement => {
            const text = textElement.textContent;
            textElement.style.setProperty('--text-length', text.length);
        });

        class ButtonEffect {
            constructor(container) {
                this.container = container;
                this.canvas = container.querySelector('.title-canvas');
                
                // Setup Three.js
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, (this.canvas.width / this.canvas.height), 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    alpha: true,
                    antialias: true 
                });
                
                // Make renderer match container size
                this.renderer.setSize(this.canvas.width, this.canvas.height);
                
                // Create cubes
                this.cubes = [];
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    shininess: 50
                });
                
                // Create cubes with randomized properties
                for(let i = 0; i < 15; i++) {
                    const cube = new THREE.Mesh(geometry, material.clone());
                    cube.position.x = (Math.random() - 0.5) * 6;
                    cube.position.y = (Math.random() - 0.5) * 1.5;
                    cube.position.z = (Math.random() - 0.5) * 2;
                    cube.baseScale = 1;
                    
                    // Add random movement properties
                    cube.moveSpeed = {
                        x: 0.005 + Math.random() * 0.01,
                        y: 0.003 + Math.random() * 0.005
                    };
                    cube.rotationSpeed = {
                        x: 0.003 + Math.random() * 0.004,
                        y: 0.003 + Math.random() * 0.004,
                        z: 0.002 + Math.random() * 0.003
                    };
                    cube.phaseOffset = Math.random() * Math.PI * 2;
                    
                    this.cubes.push(cube);
                    this.scene.add(cube);
                }
                
                // Adjust lighting
                const light = new THREE.DirectionalLight(0xffffff, 0.7);
                light.position.set(0, 1, 2);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.3));
                
                this.camera.position.z = 5;
                
                // Start animation
                this.animate();
                
                // Update colors based on step
                this.updateColors(this.container.dataset.step);
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleResize() {
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            animate = () => {
                requestAnimationFrame(this.animate);
                const time = Date.now() * 0.001;
                
                this.cubes.forEach(cube => {
                    // Create varied flowing motion
                    cube.position.x += Math.sin(time + cube.phaseOffset) * cube.moveSpeed.x;
                    cube.position.y += Math.cos(time + cube.phaseOffset) * cube.moveSpeed.y;
                    
                    // Individual rotation speeds
                    cube.rotation.x += cube.rotationSpeed.x;
                    cube.rotation.y += cube.rotationSpeed.y;
                    cube.rotation.z += cube.rotationSpeed.z;
                    
                    // Calculate distance from bounds
                    const xBound = 4;
                    const yBound = 2;
                    const xDistance = Math.abs(cube.position.x) / xBound;
                    const yDistance = Math.abs(cube.position.y) / yBound;
                    
                    // Calculate scale based on distance from bounds
                    const distanceFromBound = Math.max(xDistance, yDistance);
                    let targetScale = 1;
                    
                    if (distanceFromBound > 0.8) {
                        targetScale = Math.max(0, 1 - (distanceFromBound - 0.8) * 5);
                        
                        if (targetScale <= 0.01) {
                            cube.position.x = (Math.random() - 0.5) * 6;
                            cube.position.y = (Math.random() - 0.5) * 1.5;
                            cube.phaseOffset = Math.random() * Math.PI * 2; // New random phase
                            targetScale = 0;
                        }
                    }
                    
                    // Smoothly interpolate scale
                    cube.scale.x += (targetScale - cube.scale.x) * 0.1;
                    cube.scale.y += (targetScale - cube.scale.y) * 0.1;
                    cube.scale.z += (targetScale - cube.scale.z) * 0.1;
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            updateColors(step) {
                const colors = {
                    '1': 0x9ED2C6,
                    '2': 0xFF7BAC,
                    '3': 0x000000
                };
                
                this.cubes.forEach(cube => {
                    cube.material.color.setHex(colors[step]);
                });
            }
        }

        // Initialize effects for all tutorial windows
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.tutorial-window').forEach(container => {
                new ButtonEffect(container);
            });
        });
    </script>
    <script src="./js/tutorial-gradient.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
</body>
</html>